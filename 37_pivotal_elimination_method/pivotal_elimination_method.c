#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define N 3  // N元1次方程式の解を求める

void main(void) {

    // 拡大係数行列を表す2次元配列
    double a[N][N+1] = {{ 2.0, 3.0,  1.0,  4.0},
                        { 4.0, 1.0, -3.0, -2.0},
                        {-1.0, 2.0,  2.0,  2.0}};
    double p, d, max, dumy;
    int i, j, k, s;

    // ピボットを0から(N-1)まで繰り返す
    for(k=0; k<=N-1; k++) {

        // ----- 以下，ピボット選択法で追加した処理 -----

        // 以下で係数の(絶対値の)最大値を求める．(以下，”絶対値の”を省略)
        max = 0;  // 係数の最大値をゼロで初期化
        s = k;    // 係数の最大値が存在する列を初期化

        for(j=k; j<=N-1; j++) {  // ピボットの存在する列において 

            if(fabs(a[j][k]) > max) {
                max = fabs(a[j][k]);  // 係数の最大値を更新
                s = j;                // 係数の最大値が存在する列を更新 
            }
        }
        
        // 最大の係数がピボットとして決定された

        if(max == 0) {  // 最大の係数が0の場合，解けない
            printf("cannot resolve\n");
            exit(1);
        }

        // (ピボットの初期値が存在する行:k行目)と(係数の最大値が存在する行:s行目)を入れ替える
        for(j=0; j<=N; j++) {
               dumy = a[k][j];
            a[k][j] = a[s][j];
            a[s][j] = dumy; 
        }

        // ----- ピボット選択法で追加した処理 ここまで -----



        // ----- 以下，前章のガウス・ジョルダン法と同様の処理 -----

        p = a[k][k];                // ピボット係数 (対角要素)

        // ピボットの存在する行の全要素をピボットで割る       
        for(j=k; j<=N; j++) {       // ピボット以前の要素は既に0であるから割らなくても良い
            a[k][j] = a[k][j] / p;  // ピボットpで割る
        }

        // ピボット以外の行について列の掃き出し
        for(i=0; i<=N-1; i++) {
            if(i != k) {               // ピボットの行を除く
                d = a[i][k];           // 各行の0を除く先頭要素

                for(j=k; j<=N; j++) {  // ピボット以降の列について適用
                    a[i][j] = a[i][j] - d * a[k][j];  // (各行の要素)-(各行の先頭の要素)*(ピボット行の各要素)の計算
                }
            }
        }
    }

    // 解の出力 (拡大係数行列におけるN+1列目の全要素)
    for(k=0; k<=N-1; k++) {
        printf("x_%d = %f\n", k+1, a[k][N]);
    }
}
